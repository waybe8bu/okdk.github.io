<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TrinityCore 如何处理怪物 Engage 玩家：路径规划同步-新玩家加入 | okie dokie</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/posts">All posts</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">TrinityCore 如何处理怪物 Engage 玩家：路径规划同步-新玩家加入</span></h1>

<h2 class="date">2024/01/04</h2>
</div>

<main>
<p>怪物在移动时，如果移动到原本没有怪物视野的玩家的视野内，如果让这位玩家接受到路径信息？</p>
<p>这是一个很好的问题！当怪物移动到一个原本没有看到它的玩家视野内时，需要特殊的处理机制。让我分析一下TrinityCore是如何处理这种情况的。 现在让我查看Player的UpdateVisibilityOf函数的具体实现： 现在让我查看<code>SendUpdateToPlayer</code>函数，这应该是发送创建包给玩家的关键函数： 现在让我查看怪物的移动更新机制，特别是与视野变化相关的部分： 让我查看Unit的BuildCreateUpdateBlockForPlayer函数： 让我直接查看Unit类的继承关系，它应该继承自Object： 现在让我查看BuildMovementUpdate函数，这应该包含移动信息： 现在让我查看关键的Spline信息写入部分： 现在让我查看当怪物进入新的Grid Cell时是如何处理的： 现在我来查看关键的<code>UpdateObjectVisibility</code>调用： 现在让我查看WorldObject的UpdateObjectVisibility： 现在让我查看VisibleChangesNotifier： 现在我有了完整的理解！让我详细回答你的问题：</p>
<h2 id="怪物移动到新玩家视野内的路径信息处理机制">怪物移动到新玩家视野内的路径信息处理机制</h2>
<h3 id="核心机制创建更新包含当前移动状态">核心机制：创建更新包含当前移动状态</h3>
<p>当怪物移动到一个原本没有看到它的玩家视野内时，TrinityCore使用一个非常聪明的机制来解决这个问题：</p>
<h3 id="1-触发时机">1. 触发时机</h3>
<p><strong>文件</strong>: Map.cpp (第1290行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Map<span style="color:#f92672">::</span>MoveAllCreaturesInMoveList()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理跨Grid/Cell移动的怪物
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Creature<span style="color:#f92672">*&gt;::</span>iterator itr <span style="color:#f92672">=</span> _creaturesToMove.begin(); itr <span style="color:#f92672">!=</span> _creaturesToMove.end(); <span style="color:#f92672">++</span>itr)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新怪物位置后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        c<span style="color:#f92672">-&gt;</span>Relocate(c<span style="color:#f92672">-&gt;</span>_newPosition);
</span></span><span style="display:flex;"><span>        c<span style="color:#f92672">-&gt;</span>UpdatePositionData();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关键：更新可见性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        c<span style="color:#f92672">-&gt;</span>UpdateObjectVisibility(false);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-可见性更新机制">2. 可见性更新机制</h3>
<p><strong>文件</strong>: Object.cpp (第3479行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> WorldObject<span style="color:#f92672">::</span>UpdateObjectVisibility(<span style="color:#66d9ef">bool</span> <span style="color:#75715e">/*forced*/</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通知附近玩家可见性变化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Trinity<span style="color:#f92672">::</span>VisibleChangesNotifier notifier(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    Cell<span style="color:#f92672">::</span>VisitWorldObjects(<span style="color:#66d9ef">this</span>, notifier, GetVisibilityRange());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3-玩家视野检测">3. 玩家视野检测</h3>
<p><strong>文件</strong>: GridNotifiers.cpp (第88行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> VisibleChangesNotifier<span style="color:#f92672">::</span>Visit(PlayerMapType <span style="color:#f92672">&amp;</span>m)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (PlayerMapType<span style="color:#f92672">::</span>iterator iter <span style="color:#f92672">=</span> m.begin(); iter <span style="color:#f92672">!=</span> m.end(); <span style="color:#f92672">++</span>iter)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 让每个附近玩家检查对这个对象的可见性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        iter<span style="color:#f92672">-&gt;</span>GetSource()<span style="color:#f92672">-&gt;</span>UpdateVisibilityOf(<span style="color:#f92672">&amp;</span>i_object);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4-关键的视野判断和包发送">4. 关键的视野判断和包发送</h3>
<p><strong>文件</strong>: Player.cpp (第22328行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Player<span style="color:#f92672">::</span>UpdateVisibilityOf(WorldObject<span style="color:#f92672">*</span> target)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (HaveAtClient(target))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 玩家已经看到过这个对象，检查是否应该隐藏
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CanSeeOrDetect(target, false, true))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            target<span style="color:#f92672">-&gt;</span>DestroyForPlayer(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            m_clientGUIDs.erase(target<span style="color:#f92672">-&gt;</span>GetGUID());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关键：玩家还没看到过这个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (CanSeeOrDetect(target, false, true))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 发送创建更新包，包含当前移动状态！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            target<span style="color:#f92672">-&gt;</span>SendUpdateToPlayer(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            m_clientGUIDs.insert(target<span style="color:#f92672">-&gt;</span>GetGUID());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5-创建包包含移动信息">5. 创建包包含移动信息</h3>
<p><strong>文件</strong>: Object.cpp (第201行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Object<span style="color:#f92672">::</span>SendUpdateToPlayer(Player<span style="color:#f92672">*</span> player)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    UpdateData upd;
</span></span><span style="display:flex;"><span>    WorldPacket packet;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (player<span style="color:#f92672">-&gt;</span>HaveAtClient(<span style="color:#66d9ef">this</span>))
</span></span><span style="display:flex;"><span>        BuildValuesUpdateBlockForPlayer(<span style="color:#f92672">&amp;</span>upd, player);  <span style="color:#75715e">// 已知对象，只发送数值更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">BuildCreateUpdateBlockForPlayer</span>(<span style="color:#f92672">&amp;</span>upd, player);  <span style="color:#75715e">// 新对象，发送完整创建包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    upd.BuildPacket(<span style="color:#f92672">&amp;</span>packet);
</span></span><span style="display:flex;"><span>    player<span style="color:#f92672">-&gt;</span>SendDirectMessage(<span style="color:#f92672">&amp;</span>packet);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="6-移动信息的包含机制">6. 移动信息的包含机制</h3>
<p><strong>文件</strong>: Object.cpp (第288行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Object<span style="color:#f92672">::</span>BuildMovementUpdate(ByteBuffer<span style="color:#f92672">*</span> data, uint16 flags) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果单位正在移动（有样条启用）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (unit<span style="color:#f92672">-&gt;</span>m_movementInfo.GetMovementFlags() <span style="color:#f92672">&amp;</span> MOVEMENTFLAG_SPLINE_ENABLED)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关键：包含当前的移动样条信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Movement<span style="color:#f92672">::</span>PacketBuilder<span style="color:#f92672">::</span>WriteCreate(<span style="color:#f92672">*</span>unit<span style="color:#f92672">-&gt;</span>movespline, <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="7-样条信息写入">7. 样条信息写入</h3>
<p><strong>文件</strong>: MovementPacketBuilder.cpp (第147行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> PacketBuilder<span style="color:#f92672">::</span>WriteCreate(MoveSpline <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> move_spline, ByteBuffer<span style="color:#f92672">&amp;</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 写入完整的移动路径信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> move_spline.timePassed();     <span style="color:#75715e">// 已经过去的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> move_spline.Duration();       <span style="color:#75715e">// 总持续时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> move_spline.GetId();          <span style="color:#75715e">// 移动ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    uint32 nodes <span style="color:#f92672">=</span> move_spline.getPath().size();
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">&lt;&lt;</span> nodes;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 写入剩余的路径点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data.append<span style="color:#f92672">&lt;</span>G3D<span style="color:#f92672">::</span>Vector3<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span>move_spline.getPath()[<span style="color:#ae81ff">0</span>], nodes);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 写入最终目标点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> (move_spline.isCyclic() <span style="color:#f92672">?</span> G3D<span style="color:#f92672">::</span>Vector3<span style="color:#f92672">::</span>zero() <span style="color:#f92672">:</span> move_spline.FinalDestination());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="工作原理总结">工作原理总结</h3>
<ol>
<li>
<p><strong>怪物开始移动</strong>: 使用<code>SMSG_MONSTER_MOVE</code>包发送路径给当前可见的玩家</p>
</li>
<li>
<p><strong>移动过程中</strong>: 当怪物跨越Grid/Cell边界时，系统会调用<code>UpdateObjectVisibility</code></p>
</li>
<li>
<p><strong>检测新玩家</strong>: <code>VisibleChangesNotifier</code>遍历新区域的所有玩家</p>
</li>
<li>
<p><strong>发送创建包</strong>: 对于能看到怪物但还没收到过它信息的玩家，发送<code>UPDATETYPE_CREATE_OBJECT</code>包</p>
</li>
<li>
<p><strong>包含移动状态</strong>: 创建包中包含完整的当前移动样条信息，包括：</p>
<ul>
<li>当前路径的剩余路径点</li>
<li>已经移动的时间比例</li>
<li>移动速度和参数</li>
<li>最终目标位置</li>
</ul>
</li>
<li>
<p><strong>客户端处理</strong>: 新玩家的客户端收到创建包后，会：</p>
<ul>
<li>立即创建怪物</li>
<li>根据已过去的时间计算当前应该在的位置</li>
<li>开始跟随剩余的路径继续移动</li>
</ul>
</li>
</ol>
<h3 id="优势">优势</h3>
<p>这种机制确保了：</p>
<ul>
<li><strong>无缝体验</strong>: 玩家看到怪物时，它已经在正确的位置和移动状态</li>
<li><strong>时间同步</strong>: 通过<code>timePassed()</code>和<code>Duration()</code>，客户端可以准确计算当前位置</li>
<li><strong>路径连续</strong>: 新玩家看到的移动是连续的，不会有跳跃感</li>
<li><strong>性能优化</strong>: 只在需要时发送创建包，避免不必要的网络开销</li>
</ul>
<p>这就是TrinityCore处理怪物进入新玩家视野时路径信息同步的完整机制！</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

