<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>[6.828] Lab 2: Memory Management | okie dokie</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/posts">All posts</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">[6.828] Lab 2: Memory Management</span></h1>

<h2 class="date">2024/01/13</h2>
</div>

<main>
<h2 id="原理分析">原理分析</h2>
<p>虚拟地址(VA) -&gt; 线性地址(LA) -&gt; 物理地址(PA)</p>
<pre tabindex="0"><code>           Selector  +--------------+         +-----------+
          ----------&gt;|              |         |           |
                     | Segmentation |         |  Paging   |
Software             |              |--------&gt;|           |----------&gt;  RAM
            Offset   |  Mechanism   |         | Mechanism |
          ----------&gt;|              |         |           |
                     +--------------+         +-----------+
            Virtual                   Linear                Physical
</code></pre><p>IA-32e 分页机制：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-12.gif" alt=""></p>
<p>一般如 c 语言的指针 CS:IP（<a href="https://en.wikipedia.org/wiki/X86#32-bit">寄存器大小</a>），实模式下通过 CS&laquo;4+IP 得到 20-bit 的物理地址，而保护模式+开启分页下的寻址过程为：</p>
<blockquote>
<p>1、段寄存器硬件设计实际有 48-bit，16-bit 的 visible part 和 32-bit 的 invisible part，16-bit 存 segment selector，通过 selector 去 GDT 找 segment descriptor，GDT 的位置由 GDTR 寄存器给出，找完之后 descriptor 会缓存到 invisible part。</p></blockquote>
<p>selector：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-6.gif" alt=""></p>
<p>descriptor：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-3.gif" alt=""></p>
<blockquote>
<p>2、descriptor.base + VA.offset 得到 LA。</p></blockquote>
<p>LA：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-8.gif" alt=""></p>
<blockquote>
<p>3、CR3 寄存器指定 PD 的位置，通过 LA.DIR 去 PD 里找到指定的 PDE(Page Directory Entry)。</p></blockquote>
<blockquote>
<p>4、通过 PDE.31~12 找到 PT 的位置，通过 LA.PAGE 去 PT 里找到指定的 PTE(Page Table Entry)。</p></blockquote>
<p>PTE：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-10.gif" alt=""></p>
<blockquote>
<p>5、最终通过 PTE.31~12 找到 page frame，再通过 LA.OFFSET 就能得到 PA。</p></blockquote>
<h2 id="代码分析">代码分析</h2>
<h3 id="简化分段机制">简化分段机制</h3>
<p><code>boot.S</code>，selector 都设置为 0：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># Set up the important data segment registers (DS, ES, SS).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xorw</span>    %ax,%ax             <span style="color:#75715e"># Segment number zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movw</span>    %ax,%ds             <span style="color:#75715e"># -&gt; Data Segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movw</span>    %ax,%es             <span style="color:#75715e"># -&gt; Extra Segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movw</span>    %ax,%ss             <span style="color:#75715e"># -&gt; Stack Segment
</span></span></span></code></pre></div><p><code>lgdt gdtdesc</code> 给 GDTR 指 GDT 的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># Bootstrap GDT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">.p2align</span> <span style="color:#ae81ff">2</span>                                <span style="color:#75715e"># force 4 byte alignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>gdt:
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SEG_NULL</span>				<span style="color:#75715e"># null seg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SEG</span>(<span style="color:#66d9ef">STA_X</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">STA_R</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0xffffffff</span>)	<span style="color:#75715e"># code seg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SEG</span>(<span style="color:#66d9ef">STA_W</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0xffffffff</span>)	        <span style="color:#75715e"># data seg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>gdtdesc:
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">.word</span>   <span style="color:#ae81ff">0x17</span>                            <span style="color:#75715e"># sizeof(gdt) - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">.long</span>   <span style="color:#66d9ef">gdt</span>                             <span style="color:#75715e"># address gdt
</span></span></span></code></pre></div><p>GDT 第一项默认空段，<code>mmu.h</code> 找字节组合的宏：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Macros to build GDT entries in assembly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define SEG_NULL						\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.word 0, 0;						\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.byte 0, 0, 0, 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SEG(type,base,lim)					\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);	\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),		\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)
</span></span></span></code></pre></div><p><code>granularity</code> 是 1 也就是单位是 page 4KB，<code>limit</code> 是 2^20，因此 code/data 段都是指向的 0~4GB。</p>
<h3 id="临时页管理">临时页管理</h3>
<p><code>entry.S</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># Load the physical address of entry_pgdir into cr3.  entry_pgdir
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># is defined in entrypgdir.c.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movl</span>	<span style="color:#66d9ef">$</span>(<span style="color:#66d9ef">RELOC</span>(<span style="color:#66d9ef">entry_pgdir</span>)), %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">movl</span>	%eax, %cr3
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Turn on paging.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movl</span>	%cr0, %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">orl</span>	<span style="color:#66d9ef">$</span>(<span style="color:#66d9ef">CR0_PE</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">CR0_PG</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">CR0_WP</span>), %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">movl</span>	%eax, %cr0
</span></span></code></pre></div><p>通过这段汇编可以知道 PD 的内容其实就是 <code>entrypgdir.c</code> 里 <code>entry_pgdir</code> 的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pte_t</span> entry_pgtable[NPTENTRIES];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__attribute__</span>((<span style="color:#a6e22e">__aligned__</span>(PGSIZE)))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pde_t</span> entry_pgdir[NPDENTRIES] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Map VA&#39;s [0, 4MB) to PA&#39;s [0, 4MB)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uintptr_t</span>)entry_pgtable <span style="color:#f92672">-</span> KERNBASE) <span style="color:#f92672">+</span> PTE_P,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Map VA&#39;s [KERNBASE, KERNBASE+4MB) to PA&#39;s [0, 4MB)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	[KERNBASE<span style="color:#f92672">&gt;&gt;</span>PDXSHIFT]
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uintptr_t</span>)entry_pgtable <span style="color:#f92672">-</span> KERNBASE) <span style="color:#f92672">+</span> PTE_P <span style="color:#f92672">+</span> PTE_W
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__attribute__</span>((<span style="color:#a6e22e">__aligned__</span>(PGSIZE)))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pte_t</span> entry_pgtable[NPTENTRIES] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x000000</span> <span style="color:#f92672">|</span> PTE_P <span style="color:#f92672">|</span> PTE_W,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 这里省略...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#ae81ff">0x3ff000</span> <span style="color:#f92672">|</span> PTE_P <span style="color:#f92672">|</span> PTE_W,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>kernel.ld</code> 已知：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SECTIONS
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Link the kernel at this address: &#34;.&#34; means the current address */</span>
</span></span><span style="display:flex;"><span>	. <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xF0100000</span>;
</span></span></code></pre></div><p><code>memlayout.h</code> 已知：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// All physical memory mapped at this address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define	KERNBASE	0xF0000000
</span></span></span></code></pre></div><p>lab1 的内存低位分布如下：</p>
<pre tabindex="0"><code>+------------------+  &lt;- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  &lt;- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  &lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &lt;- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  &lt;- 0x00000000
</code></pre><p>因此，很容易看出，通过 &ldquo;手搓&rdquo; <code>entry_pgtable</code> 的方式，直接将 PT 硬编码固定映射到 PA 0~4MB 的区间，由于 <code>KERNBASE</code> 的 VA 是 <code>0xF0000000</code>，为了避开 IO hole，link address 选在了 <code>0xF0100000</code>。</p>
<p>之所以有这个临时的页管理，是因为 <code>entry.S</code> 部分执行完分页就已经开启了，后续 c 语言一起 link 进来的代码也已经是 VA，但是分页真正的动态管理初始化代码还没有执行完，所以就需要一个 tiny 且固定的 PD/PT 暂时可用，这样在 <code>entry.S</code> 执行完到动态页管理完全生效之前的这部分 c 代码才能正常执行。</p>
<h3 id="正式页管理">正式页管理</h3>
<p>TODO</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

