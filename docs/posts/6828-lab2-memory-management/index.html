<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>[6.828] Lab 2: Memory Management | okie dokie</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/posts">All posts</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">[6.828] Lab 2: Memory Management</span></h1>

<h2 class="date">2024/01/13</h2>
</div>

<main>
<h2 id="原理分析">原理分析</h2>
<p>虚拟地址(VA) -&gt; 线性地址(LA) -&gt; 物理地址(PA)</p>
<pre tabindex="0"><code>           Selector  +--------------+         +-----------+
          ----------&gt;|              |         |           |
                     | Segmentation |         |  Paging   |
Software             |              |--------&gt;|           |----------&gt;  RAM
            Offset   |  Mechanism   |         | Mechanism |
          ----------&gt;|              |         |           |
                     +--------------+         +-----------+
            Virtual                   Linear                Physical
</code></pre><p>IA-32e 分页机制：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-12.gif" alt=""></p>
<p>一般如 c 语言的指针 CS:IP（<a href="https://en.wikipedia.org/wiki/X86#32-bit">寄存器大小</a>），实模式下通过 CS&laquo;4+IP 得到 20-bit 的物理地址，而保护模式+开启分页下的寻址过程为：</p>
<blockquote>
<p>1、段寄存器硬件设计实际有 48-bit，16-bit 的 visible part 和 32-bit 的 invisible part，16-bit 存 segment selector，通过 selector 去 GDT 找 segment descriptor，GDT 的位置由 GDTR 寄存器给出，找完之后 descriptor 会缓存到 invisible part。</p></blockquote>
<p>selector：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-6.gif" alt=""></p>
<p>descriptor：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-3.gif" alt=""></p>
<blockquote>
<p>2、descriptor.base + VA.offset 得到 LA。</p></blockquote>
<p>LA：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-8.gif" alt=""></p>
<blockquote>
<p>3、CR3 寄存器指定 PD 的位置，通过 LA.DIR 去 PD 里找到指定的 PDE(Page Directory Entry)。</p></blockquote>
<blockquote>
<p>4、通过 PDE.31~12 找到 PT 的位置，通过 LA.PAGE 去 PT 里找到指定的 PTE(Page Table Entry)。</p></blockquote>
<p>PTE：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-10.gif" alt=""></p>
<blockquote>
<p>5、最终通过 PTE.31~12 找到 page frame，再通过 LA.OFFSET 就能得到 PA。</p></blockquote>
<h2 id="代码分析">代码分析</h2>
<h3 id="简化分段机制">简化分段机制</h3>
<p><code>boot.S</code>，selector 都设置为 0：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># Set up the important data segment registers (DS, ES, SS).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xorw</span>    %ax,%ax             <span style="color:#75715e"># Segment number zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movw</span>    %ax,%ds             <span style="color:#75715e"># -&gt; Data Segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movw</span>    %ax,%es             <span style="color:#75715e"># -&gt; Extra Segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movw</span>    %ax,%ss             <span style="color:#75715e"># -&gt; Stack Segment
</span></span></span></code></pre></div><p><code>lgdt gdtdesc</code> 给 GDTR 指 GDT 的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># Bootstrap GDT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">.p2align</span> <span style="color:#ae81ff">2</span>                                <span style="color:#75715e"># force 4 byte alignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>gdt:
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SEG_NULL</span>				<span style="color:#75715e"># null seg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SEG</span>(<span style="color:#66d9ef">STA_X</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">STA_R</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0xffffffff</span>)	<span style="color:#75715e"># code seg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SEG</span>(<span style="color:#66d9ef">STA_W</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0xffffffff</span>)	        <span style="color:#75715e"># data seg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>gdtdesc:
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">.word</span>   <span style="color:#ae81ff">0x17</span>                            <span style="color:#75715e"># sizeof(gdt) - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">.long</span>   <span style="color:#66d9ef">gdt</span>                             <span style="color:#75715e"># address gdt
</span></span></span></code></pre></div><p>GDT 第一项默认空段，<code>mmu.h</code> 找字节组合的宏：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Macros to build GDT entries in assembly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define SEG_NULL						\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.word 0, 0;						\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.byte 0, 0, 0, 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SEG(type,base,lim)					\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);	\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),		\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)
</span></span></span></code></pre></div><p><code>granularity</code> 是 1 也就是单位是 page 4KB，<code>limit</code> 是 2^20，因此 code/data 段都是指向的 0~4GB。</p>
<h3 id="临时页管理">临时页管理</h3>
<p><code>entry.S</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># Load the physical address of entry_pgdir into cr3.  entry_pgdir
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># is defined in entrypgdir.c.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movl</span>	<span style="color:#66d9ef">$</span>(<span style="color:#66d9ef">RELOC</span>(<span style="color:#66d9ef">entry_pgdir</span>)), %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">movl</span>	%eax, %cr3
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Turn on paging.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">movl</span>	%cr0, %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">orl</span>	<span style="color:#66d9ef">$</span>(<span style="color:#66d9ef">CR0_PE</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">CR0_PG</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">CR0_WP</span>), %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">movl</span>	%eax, %cr0
</span></span></code></pre></div><p>通过这段汇编可以知道 PD 的内容其实就是 <code>entrypgdir.c</code> 里 <code>entry_pgdir</code> 的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pte_t</span> entry_pgtable[NPTENTRIES];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__attribute__</span>((<span style="color:#a6e22e">__aligned__</span>(PGSIZE)))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pde_t</span> entry_pgdir[NPDENTRIES] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Map VA&#39;s [0, 4MB) to PA&#39;s [0, 4MB)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uintptr_t</span>)entry_pgtable <span style="color:#f92672">-</span> KERNBASE) <span style="color:#f92672">+</span> PTE_P,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Map VA&#39;s [KERNBASE, KERNBASE+4MB) to PA&#39;s [0, 4MB)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	[KERNBASE<span style="color:#f92672">&gt;&gt;</span>PDXSHIFT]
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uintptr_t</span>)entry_pgtable <span style="color:#f92672">-</span> KERNBASE) <span style="color:#f92672">+</span> PTE_P <span style="color:#f92672">+</span> PTE_W
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__attribute__</span>((<span style="color:#a6e22e">__aligned__</span>(PGSIZE)))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pte_t</span> entry_pgtable[NPTENTRIES] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x000000</span> <span style="color:#f92672">|</span> PTE_P <span style="color:#f92672">|</span> PTE_W,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 这里省略...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#ae81ff">0x3ff000</span> <span style="color:#f92672">|</span> PTE_P <span style="color:#f92672">|</span> PTE_W,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>kernel.ld</code> 已知：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SECTIONS
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Link the kernel at this address: &#34;.&#34; means the current address */</span>
</span></span><span style="display:flex;"><span>	. <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xF0100000</span>;
</span></span></code></pre></div><p><code>memlayout.h</code> 已知：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// All physical memory mapped at this address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define	KERNBASE	0xF0000000
</span></span></span></code></pre></div><p>lab1 的内存低位分布如下：</p>
<pre tabindex="0"><code>+------------------+  &lt;- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  &lt;- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  &lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &lt;- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  &lt;- 0x00000000
</code></pre><p>因此，很容易看出，通过 &ldquo;手搓&rdquo; <code>entry_pgtable</code> 的方式，直接将 PT 硬编码固定映射到 PA 0~4MB 的区间，由于 <code>KERNBASE</code> 的 VA 是 <code>0xF0000000</code>，为了避开 IO hole，link address 选在了 <code>0xF0100000</code>。</p>
<p>之所以有这个临时的页管理，是因为 <code>entry.S</code> 部分执行完分页就已经开启了，后续 c 语言一起 link 进来的代码也已经是 VA，但是分页真正的动态管理初始化代码还没有执行完，所以就需要一个 tiny 且固定的 PD/PT 暂时可用，这样在 <code>entry.S</code> 执行完到动态页管理完全生效之前的这部分 c 代码才能正常执行。</p>
<h3 id="正式页管理">正式页管理</h3>
<p><code>entry.S</code> 第一个调用的 c 方法是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># now to C code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">call</span>	<span style="color:#66d9ef">i386_init</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">i386_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">char</span> edata[], end[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Before doing anything else, complete the ELF loading process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Clear the uninitialized global data (BSS) section of our program.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// This ensures that all static/global variables start out zero.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memset</span>(edata, <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">-</span> edata);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Initialize the console.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Can&#39;t call cprintf until after we do this!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cons_init</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cprintf</span>(<span style="color:#e6db74">&#34;6828 decimal is %o octal!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">6828</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Lab 2 memory management initialization functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mem_init</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Drop into the kernel monitor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">monitor</span>(NULL);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着（补全参考 <a href="https://qiita.com/kagurazakakotori/items/4232da25c412a0403c10">https://qiita.com/kagurazakakotori/items/4232da25c412a0403c10</a>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// This simple physical memory allocator is used only while JOS is setting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// up its virtual memory system.  page_alloc() is the real allocator.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If n&gt;0, allocates enough pages of contiguous physical memory to hold &#39;n&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// bytes.  Doesn&#39;t initialize the memory.  Returns a kernel virtual address.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If n==0, returns the address of the next free page without allocating
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// anything.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If we&#39;re out of memory, boot_alloc should panic.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This function may ONLY be used during initialization,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// before the page_free_list list has been set up.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">boot_alloc</span>(<span style="color:#66d9ef">uint32_t</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>nextfree;	<span style="color:#75715e">// virtual address of next byte of free memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Initialize nextfree if this is the first time.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// &#39;end&#39; is a magic symbol automatically generated by the linker,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// which points to the end of the kernel&#39;s bss segment:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// the first virtual address that the linker did *not* assign
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// to any kernel code or global variables.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nextfree) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">char</span> end[];
</span></span><span style="display:flex;"><span>		nextfree <span style="color:#f92672">=</span> <span style="color:#a6e22e">ROUNDUP</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) end, PGSIZE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Allocate a chunk large enough to hold &#39;n&#39; bytes, then update
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// nextfree.  Make sure nextfree is kept aligned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// to a multiple of PGSIZE.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// LAB 2: Your code here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	result <span style="color:#f92672">=</span> nextfree;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		nextfree <span style="color:#f92672">=</span> <span style="color:#a6e22e">ROUNDUP</span>(nextfree <span style="color:#f92672">+</span> n, PGSIZE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (((<span style="color:#66d9ef">uint32_t</span>) nextfree <span style="color:#f92672">-</span> KERNBASE) <span style="color:#f92672">&gt;</span> (npages <span style="color:#f92672">*</span> PGSIZE)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;boot_alloc: out of memory. Requested %uK, available %uK.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">uint32_t</span>) nextfree <span style="color:#f92672">/</span> <span style="color:#ae81ff">1024</span>, npages <span style="color:#f92672">*</span> PGSIZE <span style="color:#f92672">/</span> <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Set up a two-level page table:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    kern_pgdir is its linear (virtual) address of the root
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This function only sets up the kernel part of the address space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (ie. addresses &gt;= UTOP).  The user part of the address space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// will be set up later.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// From UTOP to ULIM, the user is allowed to read but not write.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Above ULIM the user cannot read or write.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mem_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> cr0;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Find out how much memory the machine has (npages &amp; npages_basemem).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">i386_detect_memory</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Remove this line when you&#39;re ready to test this function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;mem_init: This function is not finished</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// create initial page directory.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	kern_pgdir <span style="color:#f92672">=</span> (<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">boot_alloc</span>(PGSIZE);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memset</span>(kern_pgdir, <span style="color:#ae81ff">0</span>, PGSIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Recursively insert PD in itself as a page table, to form
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// a virtual page table at virtual address UVPT.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (For now, you don&#39;t have understand the greater purpose of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// following line.)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Permissions: kernel R, user R
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	kern_pgdir[<span style="color:#a6e22e">PDX</span>(UVPT)] <span style="color:#f92672">=</span> <span style="color:#a6e22e">PADDR</span>(kern_pgdir) <span style="color:#f92672">|</span> PTE_U <span style="color:#f92672">|</span> PTE_P;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Allocate an array of npages &#39;struct PageInfo&#39;s and store it in &#39;pages&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// The kernel uses this array to keep track of physical pages: for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// each physical page, there is a corresponding struct PageInfo in this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// array.  &#39;npages&#39; is the number of physical pages in memory.  Use memset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// to initialize all fields of each struct PageInfo to 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Your code goes here:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pages <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>)<span style="color:#a6e22e">boot_alloc</span>(npages <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> PageInfo));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memset</span>(pages, <span style="color:#ae81ff">0</span>, npages <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> PageInfo));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Now that we&#39;ve allocated the initial kernel data structures, we set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// up the list of free physical pages. Once we&#39;ve done so, all further
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// memory management will go through the page_* functions. In
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// particular, we can now map memory using boot_map_region
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// or page_insert
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">page_init</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">check_page_free_list</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">check_page_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">check_page</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Now we set up virtual memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Map &#39;pages&#39; read-only by the user at linear address UPAGES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Permissions:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//    - the new image at UPAGES -- kernel R, user R
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//      (ie. perm = PTE_U | PTE_P)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//    - pages itself -- kernel RW, user NONE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Your code goes here:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">boot_map_region</span>(kern_pgdir, UPAGES, PTSIZE, <span style="color:#a6e22e">PADDR</span>(pages), PTE_U <span style="color:#f92672">|</span> PTE_P);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Use the physical memory that &#39;bootstack&#39; refers to as the kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// stack.  The kernel stack grows down from virtual address KSTACKTOP.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// to be the kernel stack, but break this into two pieces:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//       the kernel overflows its stack, it will fault rather than
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//       overwrite memory.  Known as a &#34;guard page&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     Permissions: kernel RW, user NONE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Your code goes here:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">boot_map_region</span>(kern_pgdir, KSTACKTOP <span style="color:#f92672">-</span> KSTKSIZE, KSTKSIZE, <span style="color:#a6e22e">PADDR</span>(bootstack), PTE_W <span style="color:#f92672">|</span> PTE_P);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//////////////////////////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Map all of physical memory at KERNBASE.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Ie.  the VA range [KERNBASE, 2^32) should map to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//      the PA range [0, 2^32 - KERNBASE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// We might not have 2^32 - KERNBASE bytes of physical memory, but
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// we just set up the mapping anyway.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Permissions: kernel RW, user NONE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Your code goes here:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">boot_map_region</span>(kern_pgdir, KERNBASE, <span style="color:#ae81ff">0xffffffff</span> <span style="color:#f92672">-</span> KERNBASE, <span style="color:#ae81ff">0</span>, PTE_W <span style="color:#f92672">|</span> PTE_P);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check that the initial page directory has been set up correctly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">check_kern_pgdir</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Switch from the minimal entry page directory to the full kern_pgdir
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// page table we just created.	Our instruction pointer should be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// somewhere between KERNBASE and KERNBASE+4MB right now, which is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// mapped the same way by both page tables.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// If the machine reboots at this point, you&#39;ve probably set up your
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// kern_pgdir wrong.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lcr3</span>(<span style="color:#a6e22e">PADDR</span>(kern_pgdir));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">check_page_free_list</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// entry.S set the really important flags in cr0 (including enabling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// paging).  Here we configure the rest of the flags that we care about.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cr0 <span style="color:#f92672">=</span> <span style="color:#a6e22e">rcr0</span>();
</span></span><span style="display:flex;"><span>	cr0 <span style="color:#f92672">|=</span> CR0_PE<span style="color:#f92672">|</span>CR0_PG<span style="color:#f92672">|</span>CR0_AM<span style="color:#f92672">|</span>CR0_WP<span style="color:#f92672">|</span>CR0_NE<span style="color:#f92672">|</span>CR0_MP;
</span></span><span style="display:flex;"><span>	cr0 <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>(CR0_TS<span style="color:#f92672">|</span>CR0_EM);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lcr0</span>(cr0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Some more checks, only possible after kern_pgdir is installed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">check_page_installed_pgdir</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Initialize page structure and memory free list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// After this is done, NEVER use boot_alloc again.  ONLY use the page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// allocator functions below to allocate and deallocate physical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// memory via the page_free_list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">page_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// The example code here marks all physical pages as free.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// However this is not truly the case.  What memory is free?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//  1) Mark physical page 0 as in use.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     This way we preserve the real-mode IDT and BIOS structures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     in case we ever need them.  (Currently we don&#39;t, but...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     is free.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     never be allocated.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//  4) Then extended memory [EXTPHYSMEM, ...).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     Some of it is in use, some is free. Where is the kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     in physical memory?  Which pages are already in use for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//     page tables and other data structures?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Change the code to reflect this.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// NB: DO NOT actually touch the physical memory corresponding to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// free pages!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">size_t</span> i;
</span></span><span style="display:flex;"><span>	pages[<span style="color:#ae81ff">0</span>].pp_ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> npages_basemem; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		pages[i].pp_ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		pages[i].pp_link <span style="color:#f92672">=</span> page_free_list;
</span></span><span style="display:flex;"><span>		page_free_list <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pages[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> IOPHYSMEM <span style="color:#f92672">/</span> PGSIZE; i <span style="color:#f92672">&lt;</span> EXTPHYSMEM <span style="color:#f92672">/</span> PGSIZE; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		pages[i].pp_ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> EXTPHYSMEM <span style="color:#f92672">/</span> PGSIZE; i <span style="color:#f92672">&lt;</span> npages; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">PADDR</span>(<span style="color:#a6e22e">boot_alloc</span>(<span style="color:#ae81ff">0</span>)) <span style="color:#f92672">/</span> PGSIZE) {
</span></span><span style="display:flex;"><span>			pages[i].pp_ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			pages[i].pp_ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			pages[i].pp_link <span style="color:#f92672">=</span> page_free_list;
</span></span><span style="display:flex;"><span>			page_free_list <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pages[i];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// returned physical page with &#39;\0&#39; bytes.  Does NOT increment the reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// count of the page - the caller must do these if necessary (either explicitly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// or via page_insert).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Be sure to set the pp_link field of the allocated page to NULL so
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// page_free can check for double-free bugs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Returns NULL if out of free memory.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint: use page2kva and memset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">page_alloc</span>(<span style="color:#66d9ef">int</span> alloc_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fill this function in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (page_free_list <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	result <span style="color:#f92672">=</span> page_free_list;
</span></span><span style="display:flex;"><span>	page_free_list <span style="color:#f92672">=</span> page_free_list<span style="color:#f92672">-&gt;</span>pp_link;
</span></span><span style="display:flex;"><span>	result<span style="color:#f92672">-&gt;</span>pp_link <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_ZERO) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memset</span>(<span style="color:#a6e22e">page2kva</span>(result), <span style="color:#ae81ff">0</span>, PGSIZE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Return a page to the free list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (This function should only be called when pp-&gt;pp_ref reaches 0.)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">page_free</span>(<span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>pp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fill this function in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// pp-&gt;pp_link is not NULL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (pp<span style="color:#f92672">-&gt;</span>pp_ref <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> pp<span style="color:#f92672">-&gt;</span>pp_link <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;page_free: cannot free page&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	pp<span style="color:#f92672">-&gt;</span>pp_link <span style="color:#f92672">=</span> page_free_list;
</span></span><span style="display:flex;"><span>	page_free_list <span style="color:#f92672">=</span> pp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Decrement the reference count on a page,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// freeing it if there are no more refs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">page_decref</span>(<span style="color:#66d9ef">struct</span> PageInfo<span style="color:#f92672">*</span> pp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>pp<span style="color:#f92672">-&gt;</span>pp_ref <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">page_free</span>(pp);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Given &#39;pgdir&#39;, a pointer to a page directory, pgdir_walk returns
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a pointer to the page table entry (PTE) for linear address &#39;va&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This requires walking the two-level page table structure.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The relevant page table page might not exist yet.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If this is true, and create == false, then pgdir_walk returns NULL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    - If the allocation fails, pgdir_walk returns NULL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    - Otherwise, the new page&#39;s reference count is incremented,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//	the page is cleared,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//	and pgdir_walk returns a pointer into the new page table page.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint 1: you can turn a PageInfo * into the physical address of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// page it refers to with page2pa() from kern/pmap.h.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint 2: the x86 MMU checks permission bits in both the page directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and the page table, so it&#39;s safe to leave permissions in the page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// directory more permissive than strictly necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint 3: look at inc/mmu.h for useful macros that manipulate page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// table and page directory entries.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pgdir_walk</span>(<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>pgdir, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>va, <span style="color:#66d9ef">int</span> create)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fill this function in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>pde <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pgdir[<span style="color:#a6e22e">PDX</span>(va)];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>pt_addr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#f92672">*</span>pde <span style="color:#f92672">&amp;</span> PTE_P)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>create) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>pp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((pp <span style="color:#f92672">=</span> <span style="color:#a6e22e">page_alloc</span>(ALLOC_ZERO)) <span style="color:#f92672">==</span> NULL) {  <span style="color:#75715e">// allocate and clear the page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		pp<span style="color:#f92672">-&gt;</span>pp_ref<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>pde <span style="color:#f92672">=</span> <span style="color:#a6e22e">page2pa</span>(pp) <span style="color:#f92672">|</span> PTE_P <span style="color:#f92672">|</span> PTE_W <span style="color:#f92672">|</span> PTE_U;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	pt_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">KADDR</span>(<span style="color:#a6e22e">PTE_ADDR</span>(<span style="color:#f92672">*</span>pde));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>)(pt_addr <span style="color:#f92672">+</span> <span style="color:#a6e22e">PTX</span>(va));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Map [va, va+size) of virtual address space to physical [pa, pa+size)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// va and pa are both page-aligned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Use permission bits perm|PTE_P for the entries.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This function is only intended to set up the ``static&#39;&#39; mappings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// above UTOP. As such, it should *not* change the pp_ref field on the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// mapped pages.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint: the TA solution uses pgdir_walk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">boot_map_region</span>(<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>pgdir, <span style="color:#66d9ef">uintptr_t</span> va, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">physaddr_t</span> pa, <span style="color:#66d9ef">int</span> perm)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fill this function in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">size_t</span> i;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">/</span> PGSIZE; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pgdir_walk</span>(pgdir, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)va, <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;boot_map_region: allocation failure&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>pte <span style="color:#f92672">=</span> pa <span style="color:#f92672">|</span> perm <span style="color:#f92672">|</span> PTE_P;
</span></span><span style="display:flex;"><span>		va <span style="color:#f92672">+=</span> PGSIZE;
</span></span><span style="display:flex;"><span>		pa <span style="color:#f92672">+=</span> PGSIZE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Map the physical page &#39;pp&#39; at virtual address &#39;va&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The permissions (the low 12 bits) of the page table entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// should be set to &#39;perm|PTE_P&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Requirements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - If there is already a page mapped at &#39;va&#39;, it should be page_remove()d.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - If necessary, on demand, a page table should be allocated and inserted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     into &#39;pgdir&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - The TLB must be invalidated if a page was formerly present at &#39;va&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Corner-case hint: Make sure to consider what happens when the same
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pp is re-inserted at the same virtual address in the same pgdir.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// However, try not to distinguish this case in your code, as this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// frequently leads to subtle bugs; there&#39;s an elegant way to handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// everything in one code path.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// RETURNS:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   0 on success
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   -E_NO_MEM, if page table couldn&#39;t be allocated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint: The TA solution is implemented using pgdir_walk, page_remove,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and page2pa.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">page_insert</span>(<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>pgdir, <span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>pp, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>va, <span style="color:#66d9ef">int</span> perm)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fill this function in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pgdir_walk</span>(pgdir, va, <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>E_NO_MEM;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	pp<span style="color:#f92672">-&gt;</span>pp_ref<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>pte <span style="color:#f92672">&amp;</span> PTE_P) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">page_remove</span>(pgdir, va);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">page2pa</span>(pp) <span style="color:#f92672">|</span> perm <span style="color:#f92672">|</span> PTE_P;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Return the page mapped at virtual address &#39;va&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If pte_store is not zero, then we store in it the address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// of the pte for this page.  This is used by page_remove and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// can be used to verify page permissions for syscall arguments,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// but should not be used by most callers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Return NULL if there is no page mapped at va.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint: the TA solution uses pgdir_walk and pa2page.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">page_lookup</span>(<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>pgdir, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>va, <span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">**</span>pte_store)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fill this function in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pgdir_walk</span>(pgdir, va, <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> (<span style="color:#f92672">*</span>pte <span style="color:#f92672">&amp;</span> PTE_P) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pte_store) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>pte_store <span style="color:#f92672">=</span> pte;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pa2page</span>(<span style="color:#a6e22e">PTE_ADDR</span>(<span style="color:#f92672">*</span>pte));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Unmaps the physical page at virtual address &#39;va&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If there is no physical page at that address, silently does nothing.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Details:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - The ref count on the physical page should decrement.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - The physical page should be freed if the refcount reaches 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - The pg table entry corresponding to &#39;va&#39; should be set to 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     (if such a PTE exists)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   - The TLB must be invalidated if you remove an entry from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     the page table.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Hint: The TA solution is implemented using page_lookup,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	tlb_invalidate, and page_decref.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">page_remove</span>(<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>pgdir, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>va)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fill this function in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>pp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((pp <span style="color:#f92672">=</span> <span style="color:#a6e22e">page_lookup</span>(pgdir, va, <span style="color:#f92672">&amp;</span>pte)) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">page_decref</span>(pp);
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>pte <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tlb_invalidate</span>(pgdir, va);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Invalidate a TLB entry, but only if the page tables being
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// edited are the ones currently in use by the processor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tlb_invalidate</span>(<span style="color:#66d9ef">pde_t</span> <span style="color:#f92672">*</span>pgdir, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>va)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Flush the entry only if we&#39;re modifying the current address space.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// For now, there is only one address space, so always invalidate.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">invlpg</span>(va);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>相关定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> PageInfo {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Next page on the free list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> PageInfo <span style="color:#f92672">*</span>pp_link;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pp_ref is the count of pointers (usually in page table entries)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// to this page, for pages allocated using page_alloc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Pages allocated at boot time using pmap.c&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// boot_alloc do not have valid reference count fields.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint16_t</span> pp_ref;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>boot_alloc()</code> 只是临时的物理内存分配方法，乍一看难以理解，主要是 <code>end</code> 是链接器脚本定义的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SECTIONS
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Link the kernel at this address: &#34;.&#34; means the current address */</span>
</span></span><span style="display:flex;"><span>	. <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xF0100000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* AT(...) gives the load address of this section, which tells
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	   the boot loader where to load the kernel in physical memory */</span>
</span></span><span style="display:flex;"><span>	.text : <span style="color:#a6e22e">AT</span>(<span style="color:#ae81ff">0x100000</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(.text .stub .text.<span style="color:#f92672">*</span> .gnu.linkonce.t.<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PROVIDE</span>(etext <span style="color:#f92672">=</span> .);	<span style="color:#75715e">/* Define the &#39;etext&#39; symbol to this value */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	.rodata : {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(.rodata .rodata.<span style="color:#f92672">*</span> .gnu.linkonce.r.<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Include debugging information in kernel memory */</span>
</span></span><span style="display:flex;"><span>	.stab : {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PROVIDE</span>(__STAB_BEGIN__ <span style="color:#f92672">=</span> .);
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(.stab);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PROVIDE</span>(__STAB_END__ <span style="color:#f92672">=</span> .);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">BYTE</span>(<span style="color:#ae81ff">0</span>)		<span style="color:#75715e">/* Force the linker to allocate space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				   for this section */</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	.stabstr : {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PROVIDE</span>(__STABSTR_BEGIN__ <span style="color:#f92672">=</span> .);
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(.stabstr);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PROVIDE</span>(__STABSTR_END__ <span style="color:#f92672">=</span> .);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">BYTE</span>(<span style="color:#ae81ff">0</span>)		<span style="color:#75715e">/* Force the linker to allocate space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				   for this section */</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Adjust the address for the data segment to the next page */</span>
</span></span><span style="display:flex;"><span>	. <span style="color:#f92672">=</span> <span style="color:#a6e22e">ALIGN</span>(<span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* The data segment */</span>
</span></span><span style="display:flex;"><span>	.data : {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(.data)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	.bss : {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PROVIDE</span>(edata <span style="color:#f92672">=</span> .);
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(.bss)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">PROVIDE</span>(end <span style="color:#f92672">=</span> .);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">BYTE</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">/</span>DISCARD<span style="color:#f92672">/</span> <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(.eh_frame .note.GNU<span style="color:#f92672">-</span>stack)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也就是紧挨着内核 BSS 段的后面，可以理解为内核代码的后面，需要注意的是方法返回的是 VA。</p>
<p>TODO</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

