<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TrinityCore 如何处理怪物 Engage 玩家 | okie dokie</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/posts">All posts</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">TrinityCore 如何处理怪物 Engage 玩家</span></h1>

<h2 class="date">2024/01/14</h2>
</div>

<main>
<p>分析/Users/10000501/Documents/chaos/c/TrinityCore-3.3.5下的代码，指出触发怪物将玩家设置为target的代码</p>
<p>GitHub Copilot: 我来帮你分析TrinityCore-3.3.5代码库中触发怪物将玩家设置为target的相关代码。首先让我了解一下代码结构。 现在让我搜索与怪物目标选择相关的代码，重点关注AI和Entities目录： 让我搜索更多关于AI和目标选择的代码： 现在让我查看更具体的AI文件来了解目标选择机制： 让我搜索更多关于目标选择的函数： 现在让我查看关键的<code>SelectVictim</code>和<code>EngageWithTarget</code>函数： 现在让我查看<code>EngageWithTarget</code>函数： 现在让我查看<code>AddThreat</code>函数，这是关键的函数： 让我继续阅读这个函数的关键部分： 现在让我查看与怪物最初激活攻击相关的代码： 现在让我查看<code>CanStartAttack</code>函数，这是决定怪物是否能开始攻击玩家的关键函数： 让我查看怪物AI更新的代码，了解怪物如何处理攻击目标： 让我查看怪物Creature类的Update方法： 现在让我查看一些常见的AI脚本，了解怪物如何选择和攻击目标： 基于我对TrinityCore 3.3.5代码的分析，我可以为你详细解释触发怪物将玩家设置为target的主要代码机制：</p>
<h2 id="trinitycore-335中怪物设置玩家为目标的代码分析">TrinityCore 3.3.5中怪物设置玩家为目标的代码分析</h2>
<h3 id="1-主要触发机制">1. 主要触发机制</h3>
<p>怪物将玩家设置为攻击目标主要通过以下几个关键代码路径：</p>
<h4 id="a-视线检测系统-moveinlineofsight">A. 视线检测系统 (<code>MoveInLineOfSight</code>)</h4>
<p><strong>文件</strong>: CreatureAI.cpp (第117行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CreatureAI<span style="color:#f92672">::</span>MoveInLineOfSight(Unit<span style="color:#f92672">*</span> who)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (me<span style="color:#f92672">-&gt;</span>IsEngaged())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (me<span style="color:#f92672">-&gt;</span>HasReactState(REACT_AGGRESSIVE) <span style="color:#f92672">&amp;&amp;</span> me<span style="color:#f92672">-&gt;</span>CanStartAttack(who, false))
</span></span><span style="display:flex;"><span>        me<span style="color:#f92672">-&gt;</span>EngageWithTarget(who);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这是最基本的攻击触发机制，当玩家进入怪物的视线范围内时，如果怪物是攻击性反应状态，就会尝试攻击。</p>
<h4 id="b-怪物能否开始攻击的判断-canstartattack">B. 怪物能否开始攻击的判断 (<code>CanStartAttack</code>)</h4>
<p><strong>文件</strong>: Creature.cpp (第1865行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> Creature<span style="color:#f92672">::</span>CanStartAttack(Unit <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> who, <span style="color:#66d9ef">bool</span> force) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsCivilian())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 免疫检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((IsImmuneToNPC() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>who<span style="color:#f92672">-&gt;</span>HasUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED))
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">||</span> (IsImmuneToPC() <span style="color:#f92672">&amp;&amp;</span> who<span style="color:#f92672">-&gt;</span>HasUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不攻击非战斗宠物
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (who<span style="color:#f92672">-&gt;</span>GetTypeId() <span style="color:#f92672">==</span> TYPEID_UNIT <span style="color:#f92672">&amp;&amp;</span> who<span style="color:#f92672">-&gt;</span>GetCreatureType() <span style="color:#f92672">==</span> CREATURE_TYPE_NON_COMBAT_PET)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Z轴距离检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CanFly() <span style="color:#f92672">&amp;&amp;</span> (GetDistanceZ(who) <span style="color:#f92672">&gt;</span> CREATURE_Z_ATTACK_RANGE <span style="color:#f92672">+</span> m_CombatDistance))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>force)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 目标可接受性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_IsTargetAcceptable(who))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 中立或距离检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (IsNeutralToAll() <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>IsWithinDistInMap(who, GetAttackDistance(who) <span style="color:#f92672">+</span> m_CombatDistance))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 基本攻击能力检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CanCreatureAttack(who, force))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 灰色怪物不主动攻击配置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (CheckNoGrayAggroConfig(who<span style="color:#f92672">-&gt;</span>GetLevelForTarget(<span style="color:#66d9ef">this</span>), GetLevelForTarget(who)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 视线检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">IsWithinLOSInMap</span>(who);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-开始攻击的核心函数-engagewithtarget">2. 开始攻击的核心函数 (<code>EngageWithTarget</code>)</h3>
<p><strong>文件</strong>: Unit.cpp (第8289行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Unit<span style="color:#f92672">::</span>EngageWithTarget(Unit<span style="color:#f92672">*</span> enemy)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>enemy)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (CanHaveThreatList())
</span></span><span style="display:flex;"><span>        m_threatManager.AddThreat(enemy, <span style="color:#ae81ff">0.0f</span>, <span style="color:#66d9ef">nullptr</span>, true, true);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">SetInCombatWith</span>(enemy);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数是怪物设置目标的关键入口点，它会将目标添加到威胁列表中。</p>
<h3 id="3-威胁系统-threatmanageraddthreat">3. 威胁系统 (<code>ThreatManager::AddThreat</code>)</h3>
<p><strong>文件</strong>: ThreatManager.cpp (第356行开始)</p>
<p>这是最核心的目标设置机制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> ThreatManager<span style="color:#f92672">::</span>AddThreat(Unit<span style="color:#f92672">*</span> target, <span style="color:#66d9ef">float</span> amount, SpellInfo <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> spell, <span style="color:#66d9ef">bool</span> ignoreModifiers, <span style="color:#66d9ef">bool</span> ignoreRedirects)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 第一步: 检查法术是否有NO_THREAT属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (spell)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (spell<span style="color:#f92672">-&gt;</span>HasAttribute(SPELL_ATTR1_NO_THREAT))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_owner<span style="color:#f92672">-&gt;</span>IsEngaged() <span style="color:#f92672">&amp;&amp;</span> spell<span style="color:#f92672">-&gt;</span>HasAttribute(SPELL_ATTR3_NO_INITIAL_AGGRO))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 确保进入战斗状态 (威胁意味着战斗!)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_owner<span style="color:#f92672">-&gt;</span>GetCombatManager().SetInCombatWith(target))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查是否已有威胁条目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> _myThreatListEntries.find(target<span style="color:#f92672">-&gt;</span>GetGUID());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> _myThreatListEntries.end())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 已存在，增加威胁值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ThreatReference<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> ref <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ref<span style="color:#f92672">-&gt;</span>IsOnline())
</span></span><span style="display:flex;"><span>            ref<span style="color:#f92672">-&gt;</span>AddThreat(amount);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建新的威胁引用并添加到威胁管理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ThreatReference<span style="color:#f92672">*</span> ref <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreatReferenceImpl(<span style="color:#66d9ef">this</span>, target);
</span></span><span style="display:flex;"><span>    PutThreatListRef(target<span style="color:#f92672">-&gt;</span>GetGUID(), ref);
</span></span><span style="display:flex;"><span>    target<span style="color:#f92672">-&gt;</span>GetThreatManager().PutThreatenedByMeRef(_owner<span style="color:#f92672">-&gt;</span>GetGUID(), ref);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ref<span style="color:#f92672">-&gt;</span>UpdateOffline();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ref<span style="color:#f92672">-&gt;</span>IsOnline())
</span></span><span style="display:flex;"><span>        ref<span style="color:#f92672">-&gt;</span>AddThreat(amount);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果没有当前受害者，更新受害者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_currentVictimRef)
</span></span><span style="display:flex;"><span>        UpdateVictim();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ProcessAIUpdates</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4-目标选择机制-selectvictim">4. 目标选择机制 (<code>SelectVictim</code>)</h3>
<p><strong>文件</strong>: Creature.cpp (第1124行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Unit<span style="color:#f92672">*</span> Creature<span style="color:#f92672">::</span>SelectVictim()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Unit<span style="color:#f92672">*</span> target <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (CanHaveThreatList())
</span></span><span style="display:flex;"><span>        target <span style="color:#f92672">=</span> GetThreatManager().GetCurrentVictim();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#f92672">!</span>HasReactState(REACT_PASSIVE))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 宠物逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        target <span style="color:#f92672">=</span> getAttackerForHelper();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>target <span style="color:#f92672">&amp;&amp;</span> IsSummon())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (Unit<span style="color:#f92672">*</span> owner <span style="color:#f92672">=</span> ToTempSummon()<span style="color:#f92672">-&gt;</span>GetOwner())
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (owner<span style="color:#f92672">-&gt;</span>IsInCombat())
</span></span><span style="display:flex;"><span>                    target <span style="color:#f92672">=</span> owner<span style="color:#f92672">-&gt;</span>getAttackerForHelper();
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// ... 更多宠物逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (target <span style="color:#f92672">&amp;&amp;</span> _IsTargetAcceptable(target) <span style="color:#f92672">&amp;&amp;</span> CanCreatureAttack(target))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>HasSpellFocus())
</span></span><span style="display:flex;"><span>            SetInFront(target);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> target;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5-ai更新循环中的目标更新">5. AI更新循环中的目标更新</h3>
<p><strong>文件</strong>: CreatureAI.cpp (第240行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> CreatureAI<span style="color:#f92672">::</span>UpdateVictim()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>IsEngaged())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>me<span style="color:#f92672">-&gt;</span>IsAlive())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        EngagementOver();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>me<span style="color:#f92672">-&gt;</span>HasReactState(REACT_PASSIVE))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Unit<span style="color:#f92672">*</span> victim <span style="color:#f92672">=</span> me<span style="color:#f92672">-&gt;</span>SelectVictim())
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (victim <span style="color:#f92672">!=</span> me<span style="color:#f92672">-&gt;</span>GetVictim())
</span></span><span style="display:flex;"><span>                AttackStart(victim);  <span style="color:#75715e">// 这里会触发目标切换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> me<span style="color:#f92672">-&gt;</span>GetVictim() <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 被动状态处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="6-特殊触发情况">6. 特殊触发情况</h3>
<h4 id="a-副本中的定期战斗脉冲">A. 副本中的定期战斗脉冲</h4>
<p><strong>文件</strong>: Creature.cpp (第785行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 如果启用了定期战斗脉冲且怪物在战斗中且在副本中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (m_combatPulseDelay <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> IsEngaged() <span style="color:#f92672">&amp;&amp;</span> GetMap()<span style="color:#f92672">-&gt;</span>IsDungeon())
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 定时逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Map<span style="color:#f92672">::</span>PlayerList <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> players <span style="color:#f92672">=</span> GetMap()<span style="color:#f92672">-&gt;</span>GetPlayers();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> player : players)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (player<span style="color:#f92672">-&gt;</span>IsAlive() <span style="color:#f92672">&amp;&amp;</span> IsHostileTo(player))
</span></span><span style="display:flex;"><span>            EngageWithTarget(player);  <span style="color:#75715e">// 强制将玩家设为目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="b-所有者战斗交互">B. 所有者战斗交互</h4>
<p><strong>文件</strong>: CreatureAI.cpp (第126行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CreatureAI<span style="color:#f92672">::</span>OnOwnerCombatInteraction(Unit<span style="color:#f92672">*</span> target)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>target <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>me<span style="color:#f92672">-&gt;</span>IsAlive())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>me<span style="color:#f92672">-&gt;</span>HasReactState(REACT_PASSIVE) <span style="color:#f92672">&amp;&amp;</span> me<span style="color:#f92672">-&gt;</span>CanStartAttack(target, true))
</span></span><span style="display:flex;"><span>        me<span style="color:#f92672">-&gt;</span>EngageWithTarget(target);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="总结">总结</h3>
<p>怪物将玩家设置为target的主要触发点：</p>
<ol>
<li><strong>视线检测</strong> - 玩家进入怪物攻击范围触发<code>MoveInLineOfSight</code></li>
<li><strong>威胁系统</strong> - 通过<code>AddThreat</code>函数将玩家添加到威胁列表</li>
<li><strong>目标选择</strong> - <code>SelectVictim</code>根据威胁列表选择最高威胁目标</li>
<li><strong>AI更新</strong> - 在每次AI更新中通过<code>UpdateVictim</code>刷新当前目标</li>
<li><strong>特殊机制</strong> - 副本脉冲、宠物辅助、法术伤害等特殊情况</li>
</ol>
<p>这整个系统确保了怪物能够智能地选择和切换攻击目标，同时保持了战斗的流畅性和逻辑性。</p>
<p>找到具有 1 个许可证类型的类似代码</p>
<p>10000501_shein: 指出CreatureAI::MoveInLineOfSight的调用链路</p>
<p>GitHub Copilot: 我来帮你分析<code>CreatureAI::MoveInLineOfSight</code>的调用链路。让我搜索相关的调用代码。 现在让我查看Grid通知机制，这是<code>MoveInLineOfSight</code>被调用的关键地方： 现在让我查看<code>CreatureUnitRelocationWorker</code>函数： 现在让我查看这些Grid通知器是在哪里被调用的： 让我查看这些通知器在哪里被触发： 现在让我搜索这些通知器是在什么时候被调用的： 现在让我查看具体的调用点，特别是Unit和Player中的调用： 现在让我查看Object类中的调用： 现在让我查看Map的Relocation方法： 让我查看Map的Update方法，那里应该有DelayedUnitRelocation的调用： 现在让我搜索哪里调用了Map的Update方法： 让我查看World或者MapManager中Map的Update调用： 现在让我查看MapManager的Update方法： 现在让我查看World类中哪里调用了MapManager的Update： 现在让我搜索World的Update在哪里被调用： 现在让我找一下具体的强制重新定位调用，比如SetPosition等函数调用： 基于我的分析，现在我可以给你完整的<code>CreatureAI::MoveInLineOfSight</code>调用链路：</p>
<h2 id="creatureaimoveinlineofsight-调用链路分析">CreatureAI::MoveInLineOfSight 调用链路分析</h2>
<h3 id="完整调用链路">完整调用链路</h3>
<pre tabindex="0"><code>1. WorldServer 主循环
   ↓
2. World::Update(diff)
   ↓
3. MapManager::Update(diff)
   ↓
4. Map::Update(diff) [对每个地图]
   ↓
5. DelayedUnitRelocation 通知器处理
   ↓
6. PlayerRelocationNotifier/CreatureRelocationNotifier::Visit()
   ↓
7. CreatureUnitRelocationWorker(Creature* c, Unit* u)
   ↓
8. CreatureAI::MoveInLineOfSight_Safe(Unit* who)
   ↓
9. CreatureAI::MoveInLineOfSight(Unit* who)
</code></pre><h3 id="详细分析">详细分析</h3>
<h4 id="1-主要触发路径">1. 主要触发路径</h4>
<p><strong>路径A: 定期地图更新</strong></p>
<ul>
<li><strong>文件</strong>: Main.cpp (第531行)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">WorldUpdateLoop</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sWorld<span style="color:#f92672">-&gt;</span>Update(diff);  <span style="color:#75715e">// 每次世界更新循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>路径B: 单位强制更新可见性</strong></p>
<ul>
<li><strong>文件</strong>: Unit.cpp (第12221行)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Unit<span style="color:#f92672">::</span>UpdateObjectVisibility(<span style="color:#66d9ef">bool</span> forced)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (forced)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// call MoveInLineOfSight for nearby creatures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Trinity<span style="color:#f92672">::</span>AIRelocationNotifier notifier(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        Cell<span style="color:#f92672">::</span>VisitAllObjects(<span style="color:#66d9ef">this</span>, notifier, GetVisibilityRange());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>路径C: 玩家进入PvP状态</strong></p>
<ul>
<li><strong>文件</strong>: Player.cpp (第20381行)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Player<span style="color:#f92672">::</span>UpdatePvPState()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// call MoveInLineOfSight for nearby contested guards
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Trinity<span style="color:#f92672">::</span>AIRelocationNotifier notifier(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    Cell<span style="color:#f92672">::</span>VisitWorldObjects(<span style="color:#66d9ef">this</span>, notifier, GetVisibilityRange());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>路径D: 生物召唤时</strong></p>
<ul>
<li><strong>文件</strong>: Object.cpp (第1946行)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TempSummon<span style="color:#f92672">*</span> Map<span style="color:#f92672">::</span>SummonCreature(...)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// call MoveInLineOfSight for nearby creatures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Trinity<span style="color:#f92672">::</span>AIRelocationNotifier notifier(<span style="color:#f92672">*</span>summon);
</span></span><span style="display:flex;"><span>    Cell<span style="color:#f92672">::</span>VisitAllObjects(summon, notifier, GetVisibilityRange());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2-核心处理函数">2. 核心处理函数</h4>
<p><strong>GridNotifiers.cpp</strong> (第128行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">CreatureUnitRelocationWorker</span>(Creature<span style="color:#f92672">*</span> c, Unit<span style="color:#f92672">*</span> u)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>u<span style="color:#f92672">-&gt;</span>IsAlive() <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>c<span style="color:#f92672">-&gt;</span>IsAlive() <span style="color:#f92672">||</span> c <span style="color:#f92672">==</span> u <span style="color:#f92672">||</span> u<span style="color:#f92672">-&gt;</span>IsInFlight())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c<span style="color:#f92672">-&gt;</span>HasUnitState(UNIT_STATE_SIGHTLESS))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (c<span style="color:#f92672">-&gt;</span>IsAIEnabled() <span style="color:#f92672">&amp;&amp;</span> c<span style="color:#f92672">-&gt;</span>CanSeeOrDetect(u, false, true))
</span></span><span style="display:flex;"><span>            c<span style="color:#f92672">-&gt;</span>AI()<span style="color:#f92672">-&gt;</span>MoveInLineOfSight_Safe(u);  <span style="color:#75715e">// 调用安全版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (u<span style="color:#f92672">-&gt;</span>GetTypeId() <span style="color:#f92672">==</span> TYPEID_PLAYER <span style="color:#f92672">&amp;&amp;</span> u<span style="color:#f92672">-&gt;</span>HasStealthAura() <span style="color:#f92672">&amp;&amp;</span> c<span style="color:#f92672">-&gt;</span>IsAIEnabled() <span style="color:#f92672">&amp;&amp;</span> c<span style="color:#f92672">-&gt;</span>CanSeeOrDetect(u, false, true, true))
</span></span><span style="display:flex;"><span>                c<span style="color:#f92672">-&gt;</span>AI()<span style="color:#f92672">-&gt;</span>TriggerAlert(u);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-安全包装函数">3. 安全包装函数</h4>
<p><strong>CreatureAI.cpp</strong> (第108行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CreatureAI<span style="color:#f92672">::</span>MoveInLineOfSight_Safe(Unit<span style="color:#f92672">*</span> who)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_moveInLOSLocked <span style="color:#f92672">==</span> true)  <span style="color:#75715e">// 防止递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    _moveInLOSLocked <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    MoveInLineOfSight(who);  <span style="color:#75715e">// 调用实际的处理函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _moveInLOSLocked <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4-实际处理函数">4. 实际处理函数</h4>
<p><strong>CreatureAI.cpp</strong> (第117行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CreatureAI<span style="color:#f92672">::</span>MoveInLineOfSight(Unit<span style="color:#f92672">*</span> who)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (me<span style="color:#f92672">-&gt;</span>IsEngaged())  <span style="color:#75715e">// 已经在战斗中则不处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (me<span style="color:#f92672">-&gt;</span>HasReactState(REACT_AGGRESSIVE) <span style="color:#f92672">&amp;&amp;</span> me<span style="color:#f92672">-&gt;</span>CanStartAttack(who, false))
</span></span><span style="display:flex;"><span>        me<span style="color:#f92672">-&gt;</span>EngageWithTarget(who);  <span style="color:#75715e">// 开始攻击目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="调用频率和时机">调用频率和时机</h3>
<ol>
<li><strong>定期调用</strong>: 每次地图更新循环中，处理需要重新定位的单位</li>
<li><strong>强制调用</strong>: 当单位位置发生重大变化时立即触发</li>
<li><strong>特殊事件</strong>: PvP状态变化、生物召唤等特殊情况</li>
</ol>
<h3 id="性能优化措施">性能优化措施</h3>
<ol>
<li><strong>安全锁</strong>: <code>_moveInLOSLocked</code> 防止递归调用造成栈溢出</li>
<li><strong>条件检查</strong>: 在<code>CreatureUnitRelocationWorker</code>中进行多重条件检查，避免不必要的AI调用</li>
<li><strong>延迟处理</strong>: 使用<code>DelayedUnitRelocation</code>将重定位处理延迟到适当时机</li>
</ol>
<p>这个调用链路确保了怪物能够及时感知到附近玩家的存在，并根据其AI设置做出相应的反应（攻击、警戒等）。</p>
<p>找到具有 1 个许可证类型的类似代码</p>
<p>10000501_shein: 怪物选择到合适的victim，完成了路径规划之后，是将路径信息发给客户端还是定时向附近玩家广播位置？</p>
<p>GitHub Copilot: 我来帮你分析怪物在选择到victim并完成路径规划后，是如何向客户端同步位置信息的。让我搜索相关的代码。 现在让我查看Movement包的相关代码： 现在让我查看MoveSplineInit.cpp文件，这应该是发送移动包的关键代码： 现在让我看看<code>SendMessageToSet</code>函数： 现在让我查看MessageDistDeliverer的实现： 现在让我看看定时位置更新的机制： 让我查看Unit的UpdatePosition方法： 现在让我看看Map的CreatureRelocation方法： 现在让我看看Movement相关的MotionMaster如何工作： 现在让我查看Spline移动系统，这是怪物移动的核心： 让我看一下Unit类中位置同步相关的代码： 基于我的分析，现在我可以全面回答你的问题：</p>
<h2 id="怪物移动同步机制分析">怪物移动同步机制分析</h2>
<h3 id="答案发送路径信息给客户端">答案：发送路径信息给客户端</h3>
<p>怪物在选择到合适的victim并完成路径规划后，<strong>主要是将完整的路径信息发送给客户端</strong>，而不是定时广播位置。</p>
<h3 id="详细机制">详细机制</h3>
<h4 id="1-路径规划完成后的处理">1. 路径规划完成后的处理</h4>
<p><strong>文件</strong>: MoveSplineInit.cpp (第130行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>uint32 MoveSplineInit<span style="color:#f92672">::</span>Launch()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 验证参数并初始化移动样条
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    move_spline.Initialize(args);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建SMSG_MONSTER_MOVE包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    WorldPacket <span style="color:#a6e22e">data</span>(SMSG_MONSTER_MOVE, <span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">&lt;&lt;</span> unit<span style="color:#f92672">-&gt;</span>GetPackGUID();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 写入完整的移动路径信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PacketBuilder<span style="color:#f92672">::</span>WriteMonsterMove(move_spline, data);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 向附近玩家广播路径包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    unit<span style="color:#f92672">-&gt;</span>SendMessageToSet(<span style="color:#f92672">&amp;</span>data, true);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> move_spline.Duration();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2-路径包的内容">2. 路径包的内容</h4>
<p>移动包包含以下信息：</p>
<ul>
<li><strong>起始位置</strong>: 怪物当前位置</li>
<li><strong>路径点序列</strong>: 完整的移动路径waypoints</li>
<li><strong>移动类型</strong>: 走路/跑步/飞行等</li>
<li><strong>移动速度</strong>: 移动速度参数</li>
<li><strong>面向信息</strong>: 面向目标、角度或位置</li>
<li><strong>移动标志</strong>: 特殊移动状态</li>
</ul>
<h4 id="3-客户端预测机制">3. 客户端预测机制</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Unit<span style="color:#f92672">::</span>UpdateSplinePosition()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 服务器端根据样条曲线计算当前位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Movement<span style="color:#f92672">::</span>Location loc <span style="color:#f92672">=</span> movespline<span style="color:#f92672">-&gt;</span>ComputePosition();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新服务器端位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    UpdatePosition(loc.x, loc.y, loc.z, loc.orientation);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>工作原理</strong>:</p>
<ol>
<li><strong>一次性发送</strong>: 服务器将完整路径一次性发送给客户端</li>
<li><strong>客户端插值</strong>: 客户端根据路径和时间进行平滑插值</li>
<li><strong>服务器计算</strong>: 服务器同时进行相同的位置计算</li>
<li><strong>同步检查</strong>: 定期验证客户端和服务器位置是否一致</li>
</ol>
<h4 id="4-位置同步机制">4. 位置同步机制</h4>
<p><strong>定时同步的情况</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> WorldObject<span style="color:#f92672">::</span>SendMessageToSet(WorldPacket <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> data, <span style="color:#66d9ef">bool</span> self) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsInWorld())
</span></span><span style="display:flex;"><span>        SendMessageToSetInRange(data, GetVisibilityRange(), self);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>同步时机</strong>:</p>
<ul>
<li><strong>立即同步</strong>: 开始新的移动时发送完整路径</li>
<li><strong>定期校验</strong>: 移动过程中偶尔发送位置校正</li>
<li><strong>状态变化</strong>: 停止、转向、速度变化时更新</li>
<li><strong>异常处理</strong>: 检测到不同步时强制校正</li>
</ul>
<h3 id="优势分析">优势分析</h3>
<h4 id="路径方式的优点">路径方式的优点:</h4>
<ol>
<li><strong>网络效率</strong>: 一次发送完整路径，减少网络包数量</li>
<li><strong>流畅性</strong>: 客户端可以进行平滑插值，移动更流畅</li>
<li><strong>预测性</strong>: 客户端可以预测移动轨迹</li>
<li><strong>延迟容忍</strong>: 网络延迟不会影响移动流畅度</li>
</ol>
<h4 id="定时位置方式的缺点">定时位置方式的缺点:</h4>
<ol>
<li><strong>网络压力</strong>: 需要频繁发送位置包</li>
<li><strong>不流畅</strong>: 移动可能出现跳跃感</li>
<li><strong>延迟敏感</strong>: 网络延迟直接影响移动表现</li>
</ol>
<h3 id="特殊情况">特殊情况</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> MoveSplineInit<span style="color:#f92672">::</span>Stop()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 停止移动时发送停止包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    WorldPacket <span style="color:#a6e22e">data</span>(SMSG_MONSTER_MOVE, <span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex;"><span>    PacketBuilder<span style="color:#f92672">::</span>WriteStopMovement(loc, args.splineId, data);
</span></span><span style="display:flex;"><span>    unit<span style="color:#f92672">-&gt;</span>SendMessageToSet(<span style="color:#f92672">&amp;</span>data, true);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>需要立即更新的情况</strong>:</p>
<ul>
<li>移动路径被打断</li>
<li>目标发生变化</li>
<li>遇到障碍物</li>
<li>进入战斗状态</li>
<li>施放法术需要停止</li>
</ul>
<h3 id="总结-1">总结</h3>
<p>TrinityCore使用的是<strong>基于路径的移动同步机制</strong>，这是现代MMO游戏的标准做法。服务器在怪物开始移动时发送完整的移动路径信息，客户端根据这些信息进行本地插值计算，实现流畅的移动效果。只有在特殊情况下才会发送额外的位置校正包。</p>
<p>10000501_shein: 怪物在移动时，如果移动到原本没有怪物视野的玩家的视野内，如果让这位玩家接受到路径信息？</p>
<p>GitHub Copilot: 这是一个很好的问题！当怪物移动到一个原本没有看到它的玩家视野内时，需要特殊的处理机制。让我分析一下TrinityCore是如何处理这种情况的。 现在让我查看Player的UpdateVisibilityOf函数的具体实现： 现在让我查看<code>SendUpdateToPlayer</code>函数，这应该是发送创建包给玩家的关键函数： 现在让我查看怪物的移动更新机制，特别是与视野变化相关的部分： 让我查看Unit的BuildCreateUpdateBlockForPlayer函数： 让我直接查看Unit类的继承关系，它应该继承自Object： 现在让我查看BuildMovementUpdate函数，这应该包含移动信息： 现在让我查看关键的Spline信息写入部分： 现在让我查看当怪物进入新的Grid Cell时是如何处理的： 现在我来查看关键的<code>UpdateObjectVisibility</code>调用： 现在让我查看WorldObject的UpdateObjectVisibility： 现在让我查看VisibleChangesNotifier： 现在我有了完整的理解！让我详细回答你的问题：</p>
<h2 id="怪物移动到新玩家视野内的路径信息处理机制">怪物移动到新玩家视野内的路径信息处理机制</h2>
<h3 id="核心机制创建更新包含当前移动状态">核心机制：创建更新包含当前移动状态</h3>
<p>当怪物移动到一个原本没有看到它的玩家视野内时，TrinityCore使用一个非常聪明的机制来解决这个问题：</p>
<h3 id="1-触发时机">1. 触发时机</h3>
<p><strong>文件</strong>: Map.cpp (第1290行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Map<span style="color:#f92672">::</span>MoveAllCreaturesInMoveList()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理跨Grid/Cell移动的怪物
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Creature<span style="color:#f92672">*&gt;::</span>iterator itr <span style="color:#f92672">=</span> _creaturesToMove.begin(); itr <span style="color:#f92672">!=</span> _creaturesToMove.end(); <span style="color:#f92672">++</span>itr)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新怪物位置后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        c<span style="color:#f92672">-&gt;</span>Relocate(c<span style="color:#f92672">-&gt;</span>_newPosition);
</span></span><span style="display:flex;"><span>        c<span style="color:#f92672">-&gt;</span>UpdatePositionData();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关键：更新可见性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        c<span style="color:#f92672">-&gt;</span>UpdateObjectVisibility(false);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-可见性更新机制">2. 可见性更新机制</h3>
<p><strong>文件</strong>: Object.cpp (第3479行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> WorldObject<span style="color:#f92672">::</span>UpdateObjectVisibility(<span style="color:#66d9ef">bool</span> <span style="color:#75715e">/*forced*/</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通知附近玩家可见性变化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Trinity<span style="color:#f92672">::</span>VisibleChangesNotifier notifier(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    Cell<span style="color:#f92672">::</span>VisitWorldObjects(<span style="color:#66d9ef">this</span>, notifier, GetVisibilityRange());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3-玩家视野检测">3. 玩家视野检测</h3>
<p><strong>文件</strong>: GridNotifiers.cpp (第88行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> VisibleChangesNotifier<span style="color:#f92672">::</span>Visit(PlayerMapType <span style="color:#f92672">&amp;</span>m)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (PlayerMapType<span style="color:#f92672">::</span>iterator iter <span style="color:#f92672">=</span> m.begin(); iter <span style="color:#f92672">!=</span> m.end(); <span style="color:#f92672">++</span>iter)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 让每个附近玩家检查对这个对象的可见性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        iter<span style="color:#f92672">-&gt;</span>GetSource()<span style="color:#f92672">-&gt;</span>UpdateVisibilityOf(<span style="color:#f92672">&amp;</span>i_object);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4-关键的视野判断和包发送">4. 关键的视野判断和包发送</h3>
<p><strong>文件</strong>: Player.cpp (第22328行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Player<span style="color:#f92672">::</span>UpdateVisibilityOf(WorldObject<span style="color:#f92672">*</span> target)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (HaveAtClient(target))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 玩家已经看到过这个对象，检查是否应该隐藏
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CanSeeOrDetect(target, false, true))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            target<span style="color:#f92672">-&gt;</span>DestroyForPlayer(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            m_clientGUIDs.erase(target<span style="color:#f92672">-&gt;</span>GetGUID());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关键：玩家还没看到过这个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (CanSeeOrDetect(target, false, true))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 发送创建更新包，包含当前移动状态！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            target<span style="color:#f92672">-&gt;</span>SendUpdateToPlayer(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            m_clientGUIDs.insert(target<span style="color:#f92672">-&gt;</span>GetGUID());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5-创建包包含移动信息">5. 创建包包含移动信息</h3>
<p><strong>文件</strong>: Object.cpp (第201行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Object<span style="color:#f92672">::</span>SendUpdateToPlayer(Player<span style="color:#f92672">*</span> player)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    UpdateData upd;
</span></span><span style="display:flex;"><span>    WorldPacket packet;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (player<span style="color:#f92672">-&gt;</span>HaveAtClient(<span style="color:#66d9ef">this</span>))
</span></span><span style="display:flex;"><span>        BuildValuesUpdateBlockForPlayer(<span style="color:#f92672">&amp;</span>upd, player);  <span style="color:#75715e">// 已知对象，只发送数值更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">BuildCreateUpdateBlockForPlayer</span>(<span style="color:#f92672">&amp;</span>upd, player);  <span style="color:#75715e">// 新对象，发送完整创建包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    upd.BuildPacket(<span style="color:#f92672">&amp;</span>packet);
</span></span><span style="display:flex;"><span>    player<span style="color:#f92672">-&gt;</span>SendDirectMessage(<span style="color:#f92672">&amp;</span>packet);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="6-移动信息的包含机制">6. 移动信息的包含机制</h3>
<p><strong>文件</strong>: Object.cpp (第288行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Object<span style="color:#f92672">::</span>BuildMovementUpdate(ByteBuffer<span style="color:#f92672">*</span> data, uint16 flags) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果单位正在移动（有样条启用）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (unit<span style="color:#f92672">-&gt;</span>m_movementInfo.GetMovementFlags() <span style="color:#f92672">&amp;</span> MOVEMENTFLAG_SPLINE_ENABLED)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关键：包含当前的移动样条信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Movement<span style="color:#f92672">::</span>PacketBuilder<span style="color:#f92672">::</span>WriteCreate(<span style="color:#f92672">*</span>unit<span style="color:#f92672">-&gt;</span>movespline, <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="7-样条信息写入">7. 样条信息写入</h3>
<p><strong>文件</strong>: MovementPacketBuilder.cpp (第147行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> PacketBuilder<span style="color:#f92672">::</span>WriteCreate(MoveSpline <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> move_spline, ByteBuffer<span style="color:#f92672">&amp;</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 写入完整的移动路径信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> move_spline.timePassed();     <span style="color:#75715e">// 已经过去的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> move_spline.Duration();       <span style="color:#75715e">// 总持续时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> move_spline.GetId();          <span style="color:#75715e">// 移动ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    uint32 nodes <span style="color:#f92672">=</span> move_spline.getPath().size();
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">&lt;&lt;</span> nodes;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 写入剩余的路径点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data.append<span style="color:#f92672">&lt;</span>G3D<span style="color:#f92672">::</span>Vector3<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span>move_spline.getPath()[<span style="color:#ae81ff">0</span>], nodes);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 写入最终目标点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    data <span style="color:#f92672">&lt;&lt;</span> (move_spline.isCyclic() <span style="color:#f92672">?</span> G3D<span style="color:#f92672">::</span>Vector3<span style="color:#f92672">::</span>zero() <span style="color:#f92672">:</span> move_spline.FinalDestination());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="工作原理总结">工作原理总结</h3>
<ol>
<li>
<p><strong>怪物开始移动</strong>: 使用<code>SMSG_MONSTER_MOVE</code>包发送路径给当前可见的玩家</p>
</li>
<li>
<p><strong>移动过程中</strong>: 当怪物跨越Grid/Cell边界时，系统会调用<code>UpdateObjectVisibility</code></p>
</li>
<li>
<p><strong>检测新玩家</strong>: <code>VisibleChangesNotifier</code>遍历新区域的所有玩家</p>
</li>
<li>
<p><strong>发送创建包</strong>: 对于能看到怪物但还没收到过它信息的玩家，发送<code>UPDATETYPE_CREATE_OBJECT</code>包</p>
</li>
<li>
<p><strong>包含移动状态</strong>: 创建包中包含完整的当前移动样条信息，包括：</p>
<ul>
<li>当前路径的剩余路径点</li>
<li>已经移动的时间比例</li>
<li>移动速度和参数</li>
<li>最终目标位置</li>
</ul>
</li>
<li>
<p><strong>客户端处理</strong>: 新玩家的客户端收到创建包后，会：</p>
<ul>
<li>立即创建怪物</li>
<li>根据已过去的时间计算当前应该在的位置</li>
<li>开始跟随剩余的路径继续移动</li>
</ul>
</li>
</ol>
<h3 id="优势">优势</h3>
<p>这种机制确保了：</p>
<ul>
<li><strong>无缝体验</strong>: 玩家看到怪物时，它已经在正确的位置和移动状态</li>
<li><strong>时间同步</strong>: 通过<code>timePassed()</code>和<code>Duration()</code>，客户端可以准确计算当前位置</li>
<li><strong>路径连续</strong>: 新玩家看到的移动是连续的，不会有跳跃感</li>
<li><strong>性能优化</strong>: 只在需要时发送创建包，避免不必要的网络开销</li>
</ul>
<p>这就是TrinityCore处理怪物进入新玩家视野时路径信息同步的完整机制！</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

